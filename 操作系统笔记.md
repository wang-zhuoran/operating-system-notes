# 操作系统笔记

[TOC]



## 0. Overview

- What is an operating system  
- History of operating systems 
- The operating system zoo 
- The Operating System Future 
- Operating system structure &Computer  Hardware 
- Operating system concepts 

​	◦ System calls,etc

![Overview](https://github.com/wang-zhuoran/operating-system-notes/blob/main/img-folder/image-overview.png)



## 1. Process 进程

<img src="https://github.com/wang-zhuoran/operating-system-notes/blob/main/img-folder/image-process-overview.png" alt="image-20210407210104184" style="zoom:67%;" />

由表及里看，什么是一个process？

### (0) Process Definition

`An abstraction of a running program`

一个进程显式的例子也很容易找到，比如一个PPT，一个正在运行的播放器，还有我现在用的编辑器Typora，都是进程的例子

### (1) Internal Structure

​	**Code Segment** - 毫无疑问, 一个程序肯定会有代码段

​	**Stack Segment** - 用于存放局部变量和返回地址的 - **区分进程和程序的重要不同之处**（另一个进程和程序的区分就是**PCB** [但是不讲process model是没法很好的理解PCB的]）

​	**Data Segment** - 用来存放全局变量

数据和代码分开存放的好处就是便于管理，和后续的内存管理是有关系的，内存的管理有一定的保护机制，比如可以把代码段设为只读的（而不是变成可写的），这时实现权限控制就比较简单（这只是一个原因！！还有别的原因）；

**那么，什么是Segment呢？**

Segment目前可以认为就是一段连续的地址空间（Adress space）

**Adress space???**

地址空间就是一堆地址的集合，而且这堆地址是线性有序的。进程是有地址空间的。操作系统是一段代码，那么它肯定要占用地址空间（当然这个地址空间是内存地址空间）那么肯定也有地址。

Kernel：操作系统代码

- Kernel Space -  操作代码所占用的地址空间
- User Space
- Kernel Mode & User Mode 内核态 & 用户态 
  - 内核态：内核空间及其拥有的权限
  - 用户态：用户空间及其拥有的权限
  - 这两个权限是不一样的！
  - 内核态下的代码是可以直接操作硬件的，而用户态下的代码是不可以的
  - 内核态和用户态的区别是硬件提供的（不是操作系统！）

用户地址空间和内核地址空间是分开的（原因还是为了权限控制）

在进程的组成部分里，有两个至关重要的部分，需要深入理解：**Stack**和**PCB**；Stack对于上层应用的开发者来说非常重要，PCB对于内核开发者来说非常重要（Stack对内核开发者来说也很重要！）

下面来看一段C的代码来帮助理解Stack的行为

``` C++
#include <string.h>
#include <stdio.h>
#incldue <stdlib.h>

void f1(char* str)
{
	int a;      //将局部变量a压入栈中
	int ms[4];  //将局部变量ms压入栈中
	int b;      //将局部变量b压入栈中
	
	a = 1;
	b = 2;
	strncpy(ms, str, 100);	
} 

int main()
{
	char* str = "1234567ahbhbiasdiabdabdisadsdasda";
	
	f1(str);
	
	return 0;	
}

```

很明显，将str复制给ms的时候，ms会发生越界。debug的时候发现，a的值会被覆盖掉。并且，ms的值变为``1234``, a的值被覆盖为了``567a``. （char是一个byte，int是4个byte）

### (2) Process Model --> PCB

<img src="https://github.com/wang-zhuoran/operating-system-notes/blob/main/img-folder/image-20210410110913576.png" alt="image-20210410110913576" style="zoom:67%;" />

在引入PCB概念之前，必须先引入另一个概念：Process Model，进程模型。

为了简单起见，假设现在系统里只有一个CPU，但是现在有4个进程要执行，那么这4个进程怎么运行？为了让这4个进程有类似并发运行的效果，也就是这4个进程能复用同一个CPU，一般是用**分时复用**的方法，也就是进程A先运行一点点，再切换到B，进程B再运行一点点，再切换到C，以此类推。从而达到人难以觉察到process switch的效果。

但是这里有一个问题，当A进程运行了假如说10ms，然后切换到B，最终有一个时刻，系统还会再切换会A来运行，那么系统如何再一次从进程A被中断或者说被打断的地方重新开始运行呢？

最直观的解决方案就是，把process A 当时中断的现场、所处的状态保存下来。

那么问题又来了，这个**现场、状态**要保存在哪呢？实际上就是存放在**PCB**里。

这个**现场**包含什么东西呢？至少要包含进程使用CPU的各个寄存器（register）（切出去之前）。

``思考题：Code Segment、Stack Segment、Data Segment要不要存？``

当然PCB还要存别的东西。

<img src="https://github.com/wang-zhuoran/operating-system-notes/blob/main/img-folder/image-20210410113058479.png" alt="image-20210410113058479" style="zoom:67%;" />

比如进程的**状态 States** 每一个进程状态对资源的需求是不同的（假设一个进程正在从网络上下载文件，但是由于网络堵塞这个进程拿不到文件的package了，这样这个进程就没法继续运行了，这时就不能让这个进程继续占用CPU了）（这时又可以引入进程调度的概念）

在后面，讲**进程调度（process scheduling）**的时候，就要利用PCB中存的信息对进程进行调度

到目前为止，进程的静态结构已经完成了

### (3) 进程的动态结构和动态行为

下面来看进程的动态结构

#### 0. 进程的创建 

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210410114152391.png" alt="image-20210410114152391" style="zoom:67%;" />

##### 创建第一个进程！

首先在系统初始化的时候，肯定会有进程被创建出来，第一个进程，”神级“进程用于创建其他的进程（用一般的命令是看不到这个进程的）之后，我们可以利用``fork()``等命令创建所谓应用进程，当然这些应用进程也可以通过系统调用创建新进程. 最终会形成一个类似树状结构的东西，在``Linux``系统上可以通过一些命令查看这个树状结构。

``思考题：举例进程创建新进程的例子。（编译器编译一个程序的时候、浏览器访问海外某个位置的服务器的时候）``

batch job：批处理，要编写一个叫做shell 脚本的东西

##### 进程的动态行为和之前的进程的静态结构之间的关系是什么？

回想进程的内部结构：

- ① Code Segment
- ② Stack Segment
- ③ Data Segment
- ④ Adress Space(Kernel Space, User Space)
- ⑤ PCB

首先操作系统会把一个程序的代码段和数据段加载到内存的不同地址空间中，接下来要生成一个栈，这个栈也要占用一个内存区域；完成这些工作以后，内存空间自然而然就生成了（操作系统代码是各个进程共享的，这个时候会对Kernel Space做一个映射）；下面要在操作系统内核里生成一个PCB。





#### 1. 进程的结束

**Termination**

- Normal exit (voluntary) 程序正常运行结束完
- Error exit (involuntary) 
- Fatal error (involuntary) 
- Killed by other process (involuntary)

**与静态结构的关系：**

当进程结束的时候，代码段、数据段、栈和PCB所占的空间都会释放掉（还有别的东西要释放）

当有一个进程想要退出的时候，如果没有经过尸检，这个进程会变成一个僵尸进程（zombie process，其空间、pid、pcb都没有释放），然后等待另一个进程来对他进行尸检（这个进程在Linux里通常是一号进程，或者是这个进程的父进程）

### (4) PCB

![image-20210418155608479](C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210418155608479.png)

内存管理这一部分就是下一章内存管理和这一章进程的一个关联处（就是通过PCB相联系的）

Working directory: 工作目录。比如在编写一个C语言程序结束以后，如果不指定讲source code存放在哪里（不值得绝对路径），那么系统会默认把这个文件存放在IDE运行的那个目录底下。做到这一点正是依赖于工作目录的存在

### (5) 进程的评测

Process perfomance measurement: CPU utilizition

![image-20210418160907476](C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210418160907476.png)

p 代表一个进程做IO的概率， n是正在进行IO的进程的数量

## 3. Thread 线程

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210418161243534.png" alt="image-20210418161243534" style="zoom:67%;" />

### What is a Thread?

线程就是进程中一个正在执行的代码片段，该代码片段可以和该进程中的其他代码片段并发执行。

`light-weight process`

### Why Thread: Thread Usage

Thread生成的代价远远小于进程。因此Thread可以提供给用户提供更短的响应时间

实际例子：

1. 多开几个线程，同时下载
2. 游戏的例子：几个坦克、飞机同时对战，可以把坦克、飞机做成线程，速度更快

### Internal Structure

和进程一样，线程也有代码段、数据段、栈、地址空间这些东西，也有类似PCB的东西，叫TCB，但是不同的是，一个进程中不同的线程是**共享代码段和数据段**的（**TCB不共享，栈也不共享**）

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210419092235940.png" alt="image-20210419092235940" style="zoom:67%;" />

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210419092550349.png" alt="image-20210419092550349" style="zoom:67%;" />



Signal and signal handler：《Linux高级编程》

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210419092942558.png" alt="image-20210419092942558" style="zoom:67%;" />

线程的三种实现方式：用户态下的实现、内核态下的实现、以及用户态和内核态的混合。所谓用户态下的实现是指线程的调度器是在用户态下实现的，这个时候操作系统是看不到线程的，它只能看到一个个进程，此时就是两级调度，就是操作系统先调度进程，然后进程在内部运行线程调度器，由线程调度器来调度线程。所谓内核态下的实现是指，线程调度器已经实现在了操作系统内核里。

关于为什么用户态下的实现不够好：假设有一个进程，内部有三个线程，其中一个正在运行，另外两个在ready状态等待运行，突然这个正在运行的线程做了一个系统调用，要抓取一个网络包，这个系统调用的请求会发送给操作系统内核，但是操作系统看不到里面的线程，就会认为这个系统调用来自于一个进程，假如这个包还没有来，那么整个进程都会被放置于ready状态，这对于另外两个线程是很不公平的。

内核态下实现不够好：从用户态到内核态需要时间上的开销

混合方案：

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210419094517946.png" alt="image-20210419094517946" style="zoom:67%;" />

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210419095041981.png" alt="image-20210419095041981" style="zoom:67%;" />

 

当然现在的服务器并不是这样做的，而是维护了一个线程池



## 4. IPC 进程间通信

- Race Condition 
- Critical Region 
- Mutual Exclusion with Busy waiting 
- Sleep & Wakeup

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210421203031856.png" alt="image-20210421203031856" style="zoom:67%;" />

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210421204204958.png" alt="image-20210421204204958" style="zoom:67%;" />

竞争条件经典场景：假如有这样两个process A 和B，他们都想要打印一些东西，于是就都想把这些东西尝试写入打印队列，但是他们同时找到了7这个slot，于是就发生了冲突，这种状况就叫race condition

**竞争冒险**（race hazard）又名**竞态条件**、**竞争条件**（race condition），它旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。

举例来说，如果计算机中的两个[进程](https://zh.wikipedia.org/wiki/进程)同时试图修改一个共享内存的内容，在没有[并发控制](https://zh.wikipedia.org/wiki/并发控制)的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。

<img src="C:\Users\Panda.W\AppData\Roaming\Typora\typora-user-images\image-20210421204905081.png" alt="image-20210421204905081" style="zoom:67%;" />



什么叫Critical region？程序中的一段要和其他的进程访问共享的存储区域，这段代码就叫critical region

帮助程序开发识别有可能发生race condition的区域，并且对这个区域加以保护

确保在执行critical region里的代码的时候不同进程能够互不影响

**类比十字路口的概念！！！**



